<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=description content="The blog of Christopher Martinez, a software developer from Fresno."><title>Docker, Compose, Go</title><link rel=canonical href=https://chrsm.org/2018/09/05/docker-compose-go/><style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:700px;margin:auto}p{margin:20px 0}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{margin:50px 0 0}#links :nth-child(2){float:right}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:12px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:12px}#content h1{font-size:20px}#content h2{font-size:18px}.posts_listing li div{font-size:12px}}*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}:root{--darkreader-neutral-background:#181a1b;--darkreader-neutral-text:#e8e6e3;--darkreader-selection-background:#004daa;--darkreader-selection-text:#e8e6e3}html{background-color:#181a1b!important}html,body,input,textarea,select,button{background-color:#181a1b}html,body,input,textarea,select,button{border-color:#736b5e;color:#e8e6e3}a{color:#3391ff}table{border-color:#545b5e}::placeholder{color:#b2aba1}input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{background-color:#555b00!important;color:#e8e6e3!important}::-webkit-scrollbar{background-color:#202324;color:#aba499}::-webkit-scrollbar-thumb{background-color:#454a4d}::-webkit-scrollbar-thumb:hover{background-color:#575e62}::-webkit-scrollbar-thumb:active{background-color:#484e51}::-webkit-scrollbar-corner{background-color:#181a1b}*{scrollbar-color:#202324 #454a4d}::selection{background-color:#004daa!important;color:#e8e6e3!important}::-moz-selection{background-color:#004daa!important;color:#e8e6e3!important}</style></head><body><section id=nav><h1><a href=https://chrsm.org/></a></h1><ul><li><a href=https://chrsm.org/>~/</a></li><li><a href=https://chrsm.org/about>~/about</a></li><li><a href=https://github.com/chrsm>~/github</a></li></ul></section><section id=content><h1>Docker, Compose, Go</h1><div id=sub-header>September 2018 Â· 6 minute read</div><div class=entry-content><p>It has been a month since I set <code>chrsm.org</code> up again. Seems like a good time to write something.</p><p>At <code>$DAYJOB</code>, we have a monorepo (<em>monorepos are SO hot right now</em>) consisting of several different
services - monoliths, microservices, things that are highly interdependent and some that are decoupled.</p><p>Not everything is written in the same language and we don&rsquo;t expect everyone to have a local environment set up
with exact versions of tools that we use, so utilities like Docker help ensure that all developers have the same
tools&mldr; at least, that is what we strive for.</p><p>For a while I&rsquo;ve worked off in the equivalent of a nuclear bunker on the Go side. I write a lot of Go for personal
projects, so I have my local environment set up to accommodate that. Naturally, this leaks into my work: <em>of course</em> I
have gofmt, gometalinter, staticcheck, dep, etc installed locally. If you&rsquo;re reviewing my code, here are the steps to
follow:</p><ul><li>dep ensure</li><li>go test -v ./&mldr;</li><li>&mldr;</li></ul><p>Oh, wait - you don&rsquo;t have Go installed? Well, I guess you&rsquo;re SoL, but you can trust me!</p><p>&mldr;</p><p>But..</p><ol><li>I&rsquo;ve shipped bad code to production</li><li>I&rsquo;ve missed obvious bugs</li><li>I&rsquo;m bad at writing the typical Go &ldquo;doc comment&rdquo; above types and functions</li></ol><p>The truth is, I don&rsquo;t trust myself, so I try to write tests where possible. I auto-format code on save.
I appreciate in-depth reviews because they can catch issues that I may have missed.</p><p>But without the proper tools available, it becomes much more difficult for the reviewer to actually verify
that your work does what it says on the tin.</p><p>So how do we fix that?</p><h3 id=goals>Goals</h3><p>The ideal state of the repository is that every developer has the same set of tools available.
At any time, they should be able to run a command and have their results in stdout as usual.
It would also be quite nice if we could have some type of web-app &ldquo;hot reload&rdquo; equivalent for these services.</p><p>What we&rsquo;re looking at implementing:</p><ul><li>formatting</li><li>linting</li><li>testing</li><li>building</li><li>rebuild-on-change</li></ul><h3 id=making-it-work>Making it work</h3><p>In order to support rebuild-on-change (&ldquo;hot reload&rdquo;), we can&rsquo;t <code>ADD</code> or <code>COPY</code> files in the Dockerfile - the changes
won&rsquo;t be reflected there. Our only choice is to use a <code>VOLUME</code>.</p><p>In this case, we&rsquo;ve made the entire <code>/go</code> path a volume rather than just the <code>company.net</code> subdirectory.
Our Go code is stored in a subfolder <code>go</code> in our repository, leaving us with a hierarchy that works well for this:</p><pre><code>/
    go/
		bin/
		src/
		pkg/
    otherapp/
    README
    ...
</code></pre><p>The contents of <code>go/bin</code> and <code>go/pkg</code> are simply gitignored.</p><p>I don&rsquo;t think this is ideal. While I do prefer to work outside of Docker, this means we can&rsquo;t
<code>go get</code> various tools as a part of the Docker build process. The snippet of our Dockerfile below highlights
this issue - it doesn&rsquo;t do anything at all.</p><pre><code>FROM golang:alpine

VOLUME /go
WORKDIR $GOPATH/src/company.net

CMD [ &quot;/bin/true&quot; ]
</code></pre><p>Instead, we rely on various docker-compose commands - only after dependencies have been installed; in order,
it&rsquo;s a bit dumb.</p><pre><code># first install dependencies
docker-compose run go sh -c &quot;go get -v -u github.com/alecthomas/gometalinter&quot;
# then do useful things..
docker-compose run go sh -c &quot;gometalinter ./...&quot;
</code></pre><p>Outside of Docker, I simply run <code>export GOPATH=/path/to/src/go</code> - so it works well in the sense that it is a real GOPATH
locally, but creates baggage for other people. If it was baked in to the base image, all they&rsquo;d need to do is pull it
down or build it themselves, leaving much less confusion when things don&rsquo;t work out of the box.</p><p>The proper way to handle this issue would be to pass only <code>/go/src/company.net</code> to the container as a volume,
but since I didn&rsquo;t end up doing that&mldr;</p><p>Leaving this issue aside for now, we&rsquo;ll hook this up to Compose via <code>docker-compose.yml</code>.</p><pre><code>version: '2'
services:
  go:
    build:
      context: ./go
      dockerfile: src/company.net/Dockerfile
    image: company/gobase:local
    volumes:
      - ./go:/go
</code></pre><p>Any services that are based on the Go code simply extend this &ldquo;go&rdquo; service within the compose file:</p><pre><code>echoserver:
    extends: gobase
    build:
      context: ./go
      dockerfile: src/company.net/cmd/echoserver/Dockerfile
    image: company/echoserver:local
    environment:
      - SOMETHING_NECESSARY=xyz
    links:
      - some-dependency
</code></pre><h3 id=making-it-easy>Making it easy</h3><p>Ship a shell script that has various commands implemented for other devs to make it simple.
Note that I did <em>not</em> write this shell script; we already had something for all current projects,
I simply added these helpers to it - credit goes to Nathan Wong.</p><pre><code>#!/bin/bash

CMD=$1

case $CMD in
	deps)
		echo docker-compose run go sh -c &quot;go get -u -v github.com/golang/dep/cmd/dep ; ...&quot;
		;;
	fmt) 
		echo docker-compose run go sh -c &quot;gofmt ./...&quot;
		;;
	lint)
		echo docker-compose run go sh -c &quot;gometalinter ./...&quot;
		;;
	test)
		echo docker-compose run go sh -c &quot;go test -v ./...&quot;
		;;
	*)
		echo &quot;$CMD not found&quot;
		exit 1
		;;
esac
</code></pre><p>These helpers make it dead-simple for anyone to test/lint/etc our Go code: just run <code>script.sh lint</code> and presto, output!
Again, annoying side effect that <code>script.sh deps</code> is required first so that gometalinter is present :-)</p><h3 id=rebuild-on-change>Rebuild on change</h3><p>But wait, there&rsquo;s more (TM). We haven&rsquo;t yet hooked anything up to rebuild the code on change.
There are a number of tools that watch files on the filesystem for changes. There are Go-specific &ldquo;watchers&rdquo;
that will run tests, lint, and all that fancy stuff but I wanted to keep this simple, especially since
installed dependencies pollute the local repository at this time. I decided just to use inotify.</p><p>In order to use it, it needs to be installed in the base image, so our Dockerfile is slightly different now:</p><pre><code>FROM golang:alpine
RUN apk add --no-cache inotify-tools
VOLUME /go
WORKDIR $GOPATH/src/company.net
CMD [ &quot;/bin/true&quot; ]
</code></pre><p>I quickly rigged up a script that rebuilds a specific service after changes to the source,
kills the old one and runs the new one. Because the entrypoint of the Dockerfile will be this script,
killing the old service doesn&rsquo;t cause it to quit, either.</p><pre><code>#!/bin/sh

WATCH=&quot;$1&quot;
CDIR=&quot;$2&quot;
EXEC=&quot;$3&quot;
INCLUDE=&quot;(\.go)&quot;

wait_kill(){
	prog=$1
	while pkill -SIGINT $prog; do
		echo &quot;.&quot;
		sleep 1
	done
}

if [ -z &quot;$WATCH&quot; ] || [ -z &quot;$CDIR&quot; ]; then
	echo &quot;Invalid command; specify watchdir, cdir and exec.&quot;
	echo &quot;Example: $0 /go/src/company.net /go/src/company.net/cmd/echoserver echoserver&quot;
	exit 1;
fi

cd $CDIR
go build -v
./$EXEC &amp;

inotifywait -m -r \
	--include $INCLUDE \
	-e close_write $WATCH \
	--format %T \
	--timefmt %M:%S \
	| \
	while read time
	do
		wait_kill $EXEC
		go build -v
		./$EXEC &amp;
	done
</code></pre><p>In order to use this script, it&rsquo;s added to the Compose file under the base &ldquo;go&rdquo; section:</p><pre><code>version: '2'
services:
  go:
    build:
      context: ./go
      dockerfile: src/company.net/Dockerfile
    image: company/go:local
    volumes:
      - ./go:/go
      - ./path/to/script.sh:/usr/bin/rebuild.sh
</code></pre><p>Each service needs its own Dockerfile at this point. <code>echoserver</code> as an example would
look something like this:</p><pre><code>FROM company/go:local

ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;rebuild.sh /go/src/company.net /go/src/company.net/cmd/echoserver echoserver&quot;]
</code></pre><h3 id=done>Done!</h3><p>That&rsquo;s it. Everyone on the team now has the same tools available to them whether they care to install Go or not.</p><p>The biggest improvements to be made here: don&rsquo;t pass the entire <code>/go</code> tree to the container and instead only pass
<code>/go/src/company.net</code>. You&rsquo;ll be able to use <code>go get</code> in the Dockerfile to add dependencies, thereby eliminating
the need to have a &ldquo;install deps&rdquo; step before using linters or any other tools you integrate with.</p></div><div id=links><a class="basic-alignment left" href=https://chrsm.org/2014/05/20/archive-environments-go/>&#171; [archive] Environments & Go</a>
<a class="basic-alignment left" href=https://chrsm.org/2019/08/27/go-small-tips-advice-and-some-gotchas/>Go: small tips, advice, and some gotchas &#187;</a></div></section></body></html>