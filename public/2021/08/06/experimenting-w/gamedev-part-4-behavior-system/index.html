<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=description content="The blog of Christopher Martinez, a software developer from Fresno."><title>Experimenting w/gamedev: Part 4 - Behavior System</title><link rel=canonical href=https://chrsm.org/2021/08/06/experimenting-w/gamedev-part-4-behavior-system/><style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:700px;margin:auto}p{margin:20px 0}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{margin:50px 0 0}#links :nth-child(2){float:right}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:12px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:12px}#content h1{font-size:20px}#content h2{font-size:18px}.posts_listing li div{font-size:12px}}*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}:root{--darkreader-neutral-background:#181a1b;--darkreader-neutral-text:#e8e6e3;--darkreader-selection-background:#004daa;--darkreader-selection-text:#e8e6e3}html{background-color:#181a1b!important}html,body,input,textarea,select,button{background-color:#181a1b}html,body,input,textarea,select,button{border-color:#736b5e;color:#e8e6e3}a{color:#3391ff}table{border-color:#545b5e}::placeholder{color:#b2aba1}input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{background-color:#555b00!important;color:#e8e6e3!important}::-webkit-scrollbar{background-color:#202324;color:#aba499}::-webkit-scrollbar-thumb{background-color:#454a4d}::-webkit-scrollbar-thumb:hover{background-color:#575e62}::-webkit-scrollbar-thumb:active{background-color:#484e51}::-webkit-scrollbar-corner{background-color:#181a1b}*{scrollbar-color:#202324 #454a4d}::selection{background-color:#004daa!important;color:#e8e6e3!important}::-moz-selection{background-color:#004daa!important;color:#e8e6e3!important}</style></head><body><section id=nav><h1><a href=https://chrsm.org/></a></h1><ul><li><a href=https://chrsm.org/>~/</a></li><li><a href=https://chrsm.org/about>~/about</a></li><li><a href=https://github.com/chrsm>~/github</a></li></ul></section><section id=content><h1>Experimenting w/gamedev: Part 4 - Behavior System</h1><div id=sub-header>August 2021 Â· 7 minute read</div><div class=entry-content><p>Last time I talked about my gamedev exploration, I decided that I wasn&rsquo;t
going to talk about <a href=https://love2d.org>LOVE2D</a> specifically. Love <em>is</em> what I am using as the
foundation, but at least for now I don&rsquo;t have anything Love-specific that is
useful enough to share&mldr;</p><p>Anyway, a week or so ago I decided I wanted to implement some rudimentary
behaviors for NPCs in the game. Making the world feel &ldquo;alive&rdquo; is pretty
important to me. Something as simple as an NPC moving around the map would
be better than them just standing like mannequins.</p><p>I began by looking into what game AI looks like and how it&rsquo;s implemented by
watching GDC talks and reading various articles.</p><p>If you&rsquo;d like to skip reading this post and take a look into what I based my
system on, here&rsquo;s a list of things that I found useful.</p><ul><li><a href=https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)>Wikipedia: Behavior Trees</a></li><li><a href=https://blog.zhaytam.com/2020/01/07/behavior-trees-introduction/>Behavior Trees Introduction</a>, Zanid Haytam</li><li><a href=https://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php>Behavior trees for AI: How they work</a></li><li><a href=https://www.researchgate.net/publication/312869797_Behavior_Trees_for_Computer_Games>Behavior Trees for Computer Games</a>, Yoones A. Sekhavat</li><li>(video) <a href="https://www.youtube.com/watch?v=6VBCXvfNlCM">Behaviour Trees: The Cornerstone of Modern Game AI</a></li><li>(video) <a href="https://www.youtube.com/watch?v=Qq_xX1JCreI">GDC: AI Arborist: Proper Cultivation and Care for Your Behavior Trees</a></li></ul><p>If you&rsquo;d like to skip this post and take a look at the library I built to use
in my &ldquo;engine&rdquo;, take a look at <a href=https://github.com/chrsm/behave>behave</a>. This is what I&rsquo;ll be detailing
today.</p><p><em>BTW: I am an amateur so please make sure you do additional research on this
topic. There are definitely things about this topic that I&rsquo;ll butcher or simply
not know about yet.</em></p><h2 id=what-are-behavior-trees>What are Behavior Trees?</h2><p>Behavior Trees are directed acyclic graphs (no cycles) that allow modeling
of tasks.</p><p>Tasks are nodes in the tree that do any kind of work and return a status that
can be used to inform their parent, which can perform an action based on said
status.</p><p><em>There&rsquo;s also event-driven behavior trees, but I won&rsquo;t go into that.</em></p><h2 id=an-example>An example</h2><p>The simplest behavior I can think up with is:</p><p><img src=https://chrsm.org/img/20210807_node_decision.png alt=img-node-simple></p><p>General execution of this can be broken down to:</p><ul><li>root executes</li><li>can-see-player? executes</li><li>if successful, execute shoot-at-player</li><li>otherwise, execute walk-around</li></ul><p>The nodes underneath the root are executed - and return a status that informs
their parent. In this case, it isn&rsquo;t exactly clear what the status is used for,
so let&rsquo;s talk about two things: Sequences and Selectors.</p><h2 id=sequences-and-selectors>Sequences and Selectors</h2><p>A Sequence is a node that has N child nodes. It runs each child until
one of them returns a &ldquo;failure&rdquo; status, at which point it stops running any
subsequent children.</p><p>In pseudocode, this might look like the following:</p><p><em>yes, this is just a function, figure out how to express as a type in your language of choice</em></p><pre tabindex=0><code>sequence(children []node) returns status {
	for node in children {
		status = node-&gt;run()

		if status != success {
			return failure
		}
	}

	return success
}
</code></pre><p>A Selector is a node with N children that runs each child until the first &ldquo;success&rdquo;,
at which point it stops running any subsequent children.</p><p>In pseudocode, this might look like:</p><pre tabindex=0><code>selector(children []node) returns status {
	for node in children {
		status = node-&gt;run()

		if status == success {
			return success
		}
	}

	return failure
}
</code></pre><p>Where this becomes useful is in our example. While the main decision is
&ldquo;is the player visible?&rdquo;, it can be modeled as a combination of both a
Sequence and a Selector.</p><p><img src=https://chrsm.org/img/20210807_node_simple.png alt=img-node-decision></p><p>The first node in our behavior could be a selector: run until we get a success.
The first node of that selector could be a sequence: run until we get a failure.
The second node of the selector could be a simple leaf that cause the NPC to
walk around.</p><p>In the sequence, we&rsquo;d have two nodes:</p><ul><li>Can see player?</li><li>Shoot at player</li></ul><p>If we can&rsquo;t see the player, execution halts and returns a failure to the
sequence, which subsequently returns that status to its parent - a selector.
The selector gets a failure status and moves on to the next node: walk around!</p><p>In the case that we <em>can</em> see the player, the player is shot and a successful
status is returned to the parent selector - causing the walk around behavior to
not be executed.</p><p><em>I do want to note that how you&rsquo;d model this is entirely up to you, this could
be modeled any number of ways. This is just what makes sense to me.</em></p><h2 id=my-implementation>My Implementation</h2><p>The library I wrote is called <a href=https://github.com/chrsm/behave>behave</a>. It&rsquo;s a bit naive, but works for my
usecase.</p><p>To instantiate some behaviors, you create a root behavior. This root is not
a sequence or selector, but runs through all behaviors regardless of their
status.</p><pre tabindex=0><code>local behavior = behave.Behavior(&#34;name&#34;, { nodes })
</code></pre><p>To add nodes to the set, you can either preconstruct the nodes and add them at
the time the root is created <em>or</em> add them dynamically:</p><pre tabindex=0><code>local node = behave.Leaf(&#34;name&#34;, function() return behave.Node.status.success end)

behavior:add(node)
</code></pre><p>The <a href=https://github.com/chrsm/behave>behave</a> repository contains an example as well as API description, so
check that out for more.</p><h2 id=my-sandbox-sample>My Sandbox Sample</h2><p>For clarity, I make a distinction between my game&rsquo;s &ldquo;engine&rdquo; and the game&rsquo;s
content. I call the latter the sandbox.</p><p>As an example, the engine has a system for <em>running</em> behaviors at regular
intervals, but doesn&rsquo;t implement any on its own. It&rsquo;s just the infrastructure.
The sandbox contains definitions of behaviors, and they&rsquo;re attached to entities
when needed. It&rsquo;s great to have these separated and keeps my code a lot cleaner.</p><blockquote><p>To the point, chrsm!</p></blockquote><p>One basic behavior I&rsquo;ve implemented is &ldquo;predefined movement&rdquo;. I can attach a
behavior to any NPC that basically says &ldquo;move from point a to b&rdquo;.</p><p>A simplified version of this code, written in <a href=https://github.com/pigpigyyy/Yuescript>Yuescript</a>
(a <a href=https://github.com/leafo/moonscript>Moonscript</a> alternative) is below.</p><p>Note that this simple version is just sideways movement and I haven&rsquo;t run it,
the actual movement behavior includes some pathfinding, collision detection,
actual points (x,y not just x), and generally more configurable.</p><pre tabindex=0><code class=language-moon data-lang=moon>MoveSideways = (entity, p1 --[[ vec2 ]], p2 --[[ vec2 ]]) -&gt;
  pos = vec\xy entity.position.x, entity.position.y

  state =
    direction: &#34;right&#34; -- which direction we should walk in
    paused: false
    pausedFor: 0.0     -- how long we&#39;ve been paused for

  -- self here referring to the entity, btw; allows for cleaner code
  (self, dt) -&gt;  
    if state.paused
      state.pausedFor += dt

      if state.pausedFor &gt; 5
        state.paused = false
	state.pausedFor = 0

      -- early return, we don&#39;t want to run anything else.
      return Node.status.success
    elseif state.direction == &#34;left&#34;
      pos.x = @position.x + (-@velocity * dt)

      state.paused = pos.x &lt;= p1.x
      state.direction = &#34;right&#34; if state.paused
    elseif state.direction == &#34;right&#34;
      pos.x = @position.x + (@velocity * dt)
      
      state.paused = pos.x &gt;= p2.x
      state.direction = &#34;left&#34; if state.paused

    -- do the actual move and then return;
    -- there should be collision detection here, too.
    -- if you can&#39;t actually move to where you want,
    -- you could force a pause.
    
    Node.status.success

return MoveSideways
</code></pre><p>With this implemented, attaching it to an NPC is fairly simple:</p><pre tabindex=0><code class=language-moon data-lang=moon>import &#34;behave&#34; as behave
import &#34;move_sideways&#34; as BehaviorMoveSideways

entity = new-instance-of-entity

node = BehaviorMoveSideways entity, vec\new{5, 0}, vec\new{10, 0}
  |&gt; behave.Leaf &#34;move_sideways&#34;, _

behavior = behave.Behavior &#34;default&#34;, { node }

entity\addBehavior behavior
</code></pre><p>At a regular interval each behavior is executed. This entity will move along
the <code>x</code> axis of a map until it reaches x=10, at which point it will stop for
about 5 seconds and then walk back to x=5.</p><p>As of right now, my implementation doesn&rsquo;t share state across nodes, so
implementing the pause behavior inside of the movement one here is necessary.
I may implement this, or simply tie a Move and Pause node together as a
selector. At any rate, this works for me at the moment.</p><p>Running this in game - along with a &ldquo;blocked&rdquo; behavior check to start a dialogue -
looks like this:</p><p><img src=https://chrsm.org/img/20210807_ex.gif alt=ingame></p><h2 id=wq>;wq</h2><p>That&rsquo;s about it. Again, I recommend reading/watching the resources at the top
of this post! The authors of those are much better at explaining these than I
am.</p></div><div id=links><a class="basic-alignment left" href=https://chrsm.org/2021/07/25/experimenting-w/building-a-game-part-3-lfs-maps/>&#171; Experimenting w/building a game: Part 3 - LFS, Maps</a>
<a class="basic-alignment left" href=https://chrsm.org/2022/02/28/opinion-vcs-commits/>Opinion: VCS Commits &#187;</a></div></section></body></html>